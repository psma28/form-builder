import { createContext, useContext, useEffect, useState } from "react";
import { LoadingContext } from "./LoadingContext";
import { payloadMapper } from "../utils/mappings/EventPayloadMapper";

export const EventManagerContext = createContext();

export function EventManagerProvider({ children }) {
  const [components, setComponents] = useState({});
  const { setLoading } = useContext(LoadingContext);

  const eventHandler = (actorId, value, events) => {
    console.log("activando eventos", actorId, value, events);
    if (events.length === 0) return;
    const rollbackEventClusters = collapseEvents(actorId).reverse();
    rollbackEventClusters.forEach((eventCluster) => {
      eventCluster.events.forEach((event) => {
        const targetId = event.target;
        const targetSchema = getComponent(targetId);
        console.log("objetivo a hacer rollback", targetSchema);
        console.log("evento a hacer rollback", event);
      });
    });
    console.log("eventos a hacer rollback", rollbackEventClusters);

    events.forEach((event) => {
      const targetId = event.target;
      const payload = payloadMapper(event.payload, value, setLoading);
      console.log("payload mapeado", payload);

      updateComponent(targetId, payload);
    });
    pushEvents(actorId, events);
  };

  

  useEffect(() => {
    console.log("detectado cambion en components", components);
  }, [components]);

  const pushComponent = (component) => {
    const { id } = component;
    if (components[id]) return;
    setComponents((prev) => ({ ...prev, [id]: component }));
  };

  const updateComponent = (id, props) => {
    setComponents((prev) => ({
      ...prev,
      [id]: { ...prev[id], ...props },
    }));
  };

  const getComponent = (id) => {
    return components[id];
  };

  /**
   * Every event is represented as a key and a value related to id
   * for example a new event cluster will have the folowing structure:
   * "actorID": payload
   * Where the payload is an object which keys may include values sush as:
   * visibility flag, item array, seeder function or value.
   */
  const [eventTree, setEventTree] = useState({});

  /**
   * This method returns the current event tree
   * @returns
   */
  const getEventTree = () => {
    return eventTree;
  };

  /**
   * This method pushes a new event cluster to the tree
   * Requires an event list and the actor ID.
   * @param {string} actorId
   * @param {Array: Event[]} events
   */
  const pushEvents = (actorId, events) => {
    setEventTree({ actorId: events, ...eventTree });
  };

  /**
   * This method collapses every event chain that has
   * been generated by an actor, for example if the actorID sent
   * is Component A, the method will remove the event cluster
   * with the matching actorID, and it will look for any other event
   * clusters that has as ActorIds the first event cluster targetId.
   * For Example: for { ...., "componentA": [{target: componentB, payload: {...}}], "componentB":[...] }
   * if the first actor Id is "componentA", the method collapses the current event cluster
   * along with the one triggered by "componentB"
   * @param {String} actorId
   * @returns {Array}
   */
  const collapseEvents = (actorId) => {
    const newEventTree = { ...eventTree };
    const collapsedEvents = [];

    const recursiveCollapse = (currentActorId) => {
      if (newEventTree[currentActorId]) {
        collapsedEvents.push(...newEventTree[currentActorId]);
        delete newEventTree[currentActorId]; 

        newEventTree[currentActorId].forEach((event) => {
          const targetId = event.target;
          recursiveCollapse(targetId);
        });
      }
    };

    recursiveCollapse(actorId);
    setEventTree(newEventTree);
    return collapsedEvents;
  };

  return (
    <EventManagerContext.Provider
      value={{
        pushComponent,
        getComponent,
        updateComponent,
        getEventTree,
        pushEvents,
        collapseEvents,
        eventHandler,
      }}
    >
      {children}
    </EventManagerContext.Provider>
  );
}
